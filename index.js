// **გადაიტანეთ ლექციაში განხილული API თქვენთან(დამოუკიდებლად დაწერეთ თავიდან) და დაამატეთ შემდეგი ფუნცქიონალები:**
// 1. გააკეთეთ იგივე Refactoring იუზერებისთვის რაც ლექციაში პროდუქტებისთვის გავაკეთეთ.
// 2. გაწერეთ ლოგიკა იუზერების კონტროლერებში(CRUD ოპერაციები)
// 3. შექმენით Middleware რომელიც დალოგავს API-ში შემოსული ყველა რექვესთის მეთოდს, URL-ს და ზუსტ დროს როდესაც ეს რექვესთი შემოვიდა
// 4. შექმენით Middleware რომელიც ამოქმედდება მხოლოდ პროდუქტების როუტებზე რექვესთის გაგზავნისას. კერძოდ მაშინ როცა ახალი პროდუქტი ემატება. Middleware-ის ლოგიკის მიხედვით პროდუქტებს ემატება ახალი ველი "slug" რომელიც პროდუქტის სახელს slug-ად აქცევს. მაგალითად Macbook Pro => macbook-pro.(გაიხსენეთ ბიბლიოთეკა slugify. ასევე, ჩვენ არ გაგვიკეთებია რექვესთის body-ს შეცვლა middleware-დან, მაგრამ მარტივია და თქვენი იმედი მაქვს :) )
// 5. შექმენით გარემოს ცვლადი სახელად PORT(config.env-ში) სადაც port-ის ნომერს შეინახავთ და server-ის მოსასმენად ამ გარემოს ცვლადს გამოიყენებთ.
// 6. შექმენით გარემოს ცვლადი სახელად isMaintenance. თუკი ის true-ს ტოლი იქნება მაშინ Middleware-ის საშუალებით ყველა როუტზე რექვესთის გაგზავნისას უნდა დააბრუნოთ შემდეგი რესპონზი: '{ message: "Site is under maintenance" }'
// 7(ბონუსი). შექმენით Middleware რომელიც აკრძალავს წუთში 10 რექვესთზე მეტის მიღებას კლიენტისგან. გამოიყენეთ [express-rate-limit](https://www.npmjs.com/package/express-rate-limit) ბიბლიოთეკა

// **გადაიტანეთ ლექციაში განხილული API თქვენთან(დამოუკიდებლად დაწერეთ თავიდან) და დაამატეთ შემდეგი ფუნცქიონალები:**
// 1. დაუმატეთ ახალი ველი ყველა პროდუქტს – სახელად stock(აღნიშნავს პროდუქტის რაოდენობას მაგ. { "stock": 10 }). შექმენით როუტი POST /buy/:id, რომელზე რექვესთის გაგზავნის შემდეგ მოცემული პროდუქტის stock 1-ით შემცირდება
// 2. წაშალეთ ყველა პროდუქტი – დაამატეთ ახალი როუტი DELETE /products/delete-all, რომელიც სრულად გაასუფთავებს პროდუქტების სიას.
// 3.დათვალეთ პროდუქტების რაოდენობა – დაამატეთ როუტი GET /products/count, რომელიც დააბრუნებს პროდუქტების საერთო რაოდენობას.
// 4.გადამოწმება მონაცემებზე – ახალი პროდუქტის დამატებისას name და price ველები სავალდებულო უნდა იყოს. თუ კლიენტმა request-ში ეს ველები არ მიუთითა გამოუტანეთ შემდეგი შეტყობინება: "name and price are required!"
// 5. აიცილეთ თავიდან დუბლიკატი პროდუქტები – სანამ ახალი პროდუქტი დაემატება, შეამოწმეთ, უკვე ხომ არ არსებობს პროდუქტი იგივე სახელით. თუ არსებობს გამოიტანეთ შემდეგი შეტყობინება: "Product already exists!"
// 6.იპოვეთ ყველაზე ძვირიანი პროდუქტი – დაამატეთ როუტი GET /products/most-expensive, რომელიც დააბრუნებს ყველაზე ძვირადღირებულ პროდუქტს.
// 7. დაამატეთ დროის ველი – როცა ახალი პროდუქტი ემატება, API-მ მიანიჭოს მას createdAt ველი მიმდინარე თარიღით.
// 8. ბოლო დამატებული პროდუქტი – დაამატეთ GET /products/latest, რომელიც დააბრუნებს ყველაზე ბოლოს დამატებულ პროდუქტს.
// 9(ბონუსი). პროდუქტების ფაილის სარეზერვო ასლი – სანამ products.json ფაილი განახლდება, მისი სარეზერვო ასლი შეინახეთ products_backup.json სახით.

// შექმენით ბაზა MongoDB-ში და დააკავშირეთ თქვენს API-სთან(იგულისხება წინა თავებში აწყობილი API).
// ჩაანაცვლეთ fs მოდული ყველა პროდუქტის კონტროლერისთვის და products.json-ის
// ნაცვლად მანიპულაციები მოახდინეთ Mongodb-ის ბაზაზე.

// დავალებები

// ```
// **გადაიტანეთ ლექციაში განხილული API თქვენთან და დაამატეთ შემდეგი ფუნცქიონალები:**

// 1. დაამატეთ ვირტუალური თვისება სახელად 'priceWithTax', რომელიც გამოითვლის პროდუქტის ფასს 20%იანი გადასახადის ჩათვლით.
// მაგალითად პროდუქტის ფასი თუ 100$-ია, priceWithTax იქნება 120$.

// 2. დაამატეთ ვირტუალური თვისება სახელად 'capacity', რომელიც ტოლი იქნება პროდუქტის ფასისა და რაოდენობის ნამრავლის.

// 3. დაუმატეთ archived ველი თითოეულ პროდუქტს(default value ექნება false). წაშლის მომენტში ბაზიდან რეალურად არ წაშალოთ პროდუქტი,
// უბრალოდ archived გახადეთ true. (აქ მეთოდის შექმნა მოგიწევთ სქემაში, დასერჩეთ)

// 4. შექმენით აგრეგაცია, რომელიც დააჯგუფებს პროდუქტებს ფასის დიაპაზონის მიხედვით. აირჩიეთ 3 ან 4 დიაპაზონი(თქვენით განსაზღვრეთ რა დიაპაზონები იყოს).
//  ამ დიაპაზონებში გამოითვალეთ რა არის პროდუქტების საშუალო, მინიმალური და მაქსიმალური ფასი. ამ აგრეგაციისთვის შექმენით ახალი როუტი.

// 5. შექმენით ახალი სქემა(კოლექცია) სახელად StockHistory. დაამატეთ pre-save middleware, რომელიც ასახავს მარაგის ცვლილებებს StockHistory-ში.
// ყოველ მარაგის ცვლილებაზე StockHistory-ში შეინახება პროდუქტის აიდი, რომლის მარაგიც შეიცვალა და განახლებული მარაგის მნიშვნელობა.
// ```

// სემინარის შემდგომი დავალება:

// ```დაამატეთ სვაგერის დოკუმენტაცია თქვენს API-ში```

// HTTP მეთოდი | აღწერა | როუტის მაგალითი
// GET | ყველა ელემენტის წამოღება | /products
// GET | ერთი ელემენტის წამოღება | /products/{id}
// POST | ახალი ელემენტის დამატება | /products
// PUT | ელემენტის სრული განახლება | /products/{id}
// PATCH | ელემენტის ნაწილობრივი განახლება | /products/{id}
// DELETE | ელემენტის წაშლა | /products/{id}

// მოქმედება | აღწერა
// GET /products/search | ძიება სახელით, ფასით, კატეგორიით
// GET /products/category/{name} | კატეგორიით ფილტრაცია
// GET /products/sort?by=price | სორტირება (ფასით, თარიღით)
// GET /products/paginate?page=1 | pagination - გვერდებად დაყოფა
// GET /products/stats | სტატისტიკა, მაგალითად რაოდენობა, საშუალო ფასი
// POST /products/{id}/review | რევიუს დამატება პროდუქტზე
// PATCH /products/{id}/toggle-active | სტატუსის ჩართ/გამორთვა
// PUT /products/bulk-update | რამდენიმე ელემენტის ერთდროული განახლება

// Route | Description
// POST /auth/register | ახალი მომხმარებლის რეგისტრაცია
// POST /auth/login | ავტორიზაცია
// GET /auth/me | ამჟამინდელი მომხმარებლის წამოღება
// POST /auth/logout | ლოგაუთი
// PATCH /users/{id}/role | როლის შეცვლა (admin, user...)

// 1. დააყენეთ PostgreSQL ლოკალურად

// 2. გადმოწერეთ Beekeeper Studio და დაკავშირდით ლოკალურ ბაზასთან.

// 3. დასტარტეთ ახალი პროექტი(როგორც ლექციაშია) და დააკავშირეთ PostgreSQL-ის ლოკალურ ბაზასთან.

// 4. გააწერეთ CRUD ოპერაციები Products-ზე PostgreSQL-ის გამოყენებით.

// 5. თან დაურთეთ Swagger-ის დოკუმენტაციაც.
